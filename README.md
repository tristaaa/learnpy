# learnpy 

[| Python Basic](https://github.com/tristaaa/learnpy/blob/master/README.md#-python-basic)<br>
&ensp;&ensp;[- Introduction to Python](https://github.com/tristaaa/learnpy/blob/master/README.md#11-introduction-to-python)<br>
&ensp;&ensp;[- Core Elements of Programs](https://github.com/tristaaa/learnpy/blob/master/README.md#12-core-elements-of-programs)<br>
[| Simple Program](https://github.com/tristaaa/learnpy/blob/master/README.md#-simple-program)<br>
&ensp;&ensp;[- Simple Algorithms](https://github.com/tristaaa/learnpy/blob/master/README.md#21-simple-algorithms)<br>
&ensp;&ensp;&ensp;&ensp;[-- Bisection Search](https://github.com/tristaaa/learnpy/blob/master/README.md#bisection-search)<br>
&ensp;&ensp;[- Functions](https://github.com/tristaaa/learnpy/blob/master/README.md#22-functions)<br>
&ensp;&ensp;&ensp;&ensp;[-- Iterative or Recursive](https://github.com/tristaaa/learnpy/blob/master/README.md#iterative-or-recursive)<br>
&ensp;&ensp;&ensp;&ensp;[-- Divide and Conquer](https://github.com/tristaaa/learnpy/blob/master/README.md#divide-and-conquer)<br>
&ensp;&ensp;[- Complete Programming Experience:polysum](https://github.com/tristaaa/learnpy/blob/master/README.md#complete-programming-experiencepolysum)<br>
&ensp;&ensp;&ensp;&ensp;[-- Credit Card Problems](https://github.com/tristaaa/learnpy/blob/master/README.md#credit-card-problems)<br>
[| Structured Types](https://github.com/tristaaa/learnpy/blob/master/README.md#-structured-types)<br>
&ensp;&ensp;[- Tuples and Lists](https://github.com/tristaaa/learnpy/blob/master/README.md#31-tuples-and-lists)<br>
&ensp;&ensp;&ensp;&ensp;[-- Tuple](https://github.com/tristaaa/learnpy/blob/master/README.md#tuple)<br>
&ensp;&ensp;&ensp;&ensp;[-- List](https://github.com/tristaaa/learnpy/blob/master/README.md#list)<br>
&ensp;&ensp;[- Dictionaries and Sets](https://github.com/tristaaa/learnpy/blob/master/README.md#32-dictionaries-and-sets)<br>
&ensp;&ensp;&ensp;&ensp;[-- Dictionary](https://github.com/tristaaa/learnpy/blob/master/README.md#dictionary)<br>
&ensp;&ensp;&ensp;&ensp;[-- Set](https://github.com/tristaaa/learnpy/blob/master/README.md#set)<br>
[| Midterm Exam](https://github.com/tristaaa/learnpy/blob/master/README.md#-midterm-exam)<br>
[| Good Programming](https://github.com/tristaaa/learnpy/blob/master/README.md#-good-programming)<br>
&ensp;&ensp;[- Testing and Debugging](https://github.com/tristaaa/learnpy/blob/master/README.md#41-testing-and-debugging)<br>
&ensp;&ensp;&ensp;&ensp;[-- Black-Box Testing and Glass-Box Testing](https://github.com/tristaaa/learnpy/blob/master/README.md#black-box-testing-and-glass-box-testing)<br>
&ensp;&ensp;&ensp;&ensp;[-- Bugs](https://github.com/tristaaa/learnpy/blob/master/README.md#bugs)<br>
&ensp;&ensp;[- Exceptions and Assertions](https://github.com/tristaaa/learnpy/blob/master/README.md#42-exceptions-and-assertions)<br>
&ensp;&ensp;&ensp;&ensp;[-- Exceptions](https://github.com/tristaaa/learnpy/blob/master/README.md#exceptions)<br>
&ensp;&ensp;&ensp;&ensp;[-- Assertions](https://github.com/tristaaa/learnpy/blob/master/README.md#assertions)<br>
[| Object Oriented Programming](https://github.com/tristaaa/learnpy/blob/master/README.md#-object-oriented-programming)<br>
&ensp;&ensp;[- Classes and Inheritance](https://github.com/tristaaa/learnpy/blob/master/README.md#51-classes-and-inheritance)<br>
&ensp;&ensp;&ensp;&ensp;[-- Object Orientes Programming(OOP)](https://github.com/tristaaa/learnpy/blob/master/README.md#object-oriented-programmingoop)<br>
&ensp;&ensp;&ensp;&ensp;[-- Class Instance](https://github.com/tristaaa/learnpy/blob/master/README.md#calss-instance)<br>
&ensp;&ensp;&ensp;&ensp;[-- Methods](https://github.com/tristaaa/learnpy/blob/master/README.md#methods)<br>
&ensp;&ensp;&ensp;&ensp;[-- Class Examples](https://github.com/tristaaa/learnpy/blob/master/README.md#class-examples)<br>
&ensp;&ensp;&ensp;&ensp;[-- Why OOP](https://github.com/tristaaa/learnpy/blob/master/README.md#why-oop)<br>
&ensp;&ensp;&ensp;&ensp;[-- Hierarchies](https://github.com/tristaaa/learnpy/blob/master/README.md#hierarchies)<br>
&ensp;&ensp;&ensp;&ensp;[-- Class Variables](https://github.com/tristaaa/learnpy/blob/master/README.md#class-variables)<br>
&ensp;&ensp;[- An Extended Example](https://github.com/tristaaa/learnpy/blob/master/README.md#52-an-extended-example)<br>
&ensp;&ensp;&ensp;&ensp;[-- Building a Class](https://github.com/tristaaa/learnpy/blob/master/README.md#building-a-class)<br>
&ensp;&ensp;&ensp;&ensp;[-- Visualizing the Hierarchy](https://github.com/tristaaa/learnpy/blob/master/README.md#visualizing-the-hierarchy)<br>
&ensp;&ensp;&ensp;&ensp;[-- Adding Another Class](https://github.com/tristaaa/learnpy/blob/master/README.md#adding-another-class)<br>
&ensp;&ensp;&ensp;&ensp;[-- Using Inherited Method](https://github.com/tristaaa/learnpy/blob/master/README.md#using-inherited-method)<br>
&ensp;&ensp;&ensp;&ensp;[-- Gradebook Example](https://github.com/tristaaa/learnpy/blob/master/README.md#gradebook-example)<br>
&ensp;&ensp;&ensp;&ensp;[-- Generators](https://github.com/tristaaa/learnpy/blob/master/README.md#generators)<br>
[| Algorithmic Complexity](https://github.com/tristaaa/learnpy/blob/master/README.md#-algorithmic-complexity)<br>
&ensp;&ensp;[- Computational Complexity](https://github.com/tristaaa/learnpy/blob/master/README.md#61-computational-complexity)<br>
&ensp;&ensp;[- Searching and Sorting Algorithms](https://github.com/tristaaa/learnpy/blob/master/README.md#62-searching-and-sorting-algorithms)<br>
[| Plotting](https://github.com/tristaaa/learnpy/blob/master/README.md#-plotting)<br>
&ensp;&ensp;[- Plotting](https://github.com/tristaaa/learnpy/blob/master/README.md#71-poltting)<br>


---
Most From Edx Course Named **Introduction to Computer Science and Programming Using Python
MITx -  6.00.1x** Taught by Eric Grimson

## | Python Basic
### 1.1 Introduction to Python

### 1.2 Core Elements of Programs

## | Simple Program
### 2.1 Simple Algorithms
1) bisectionSearch_1.py

    get the guess square root of x which is greater than 1
2) bisectionSearch_2.py

    get the guess square root of x which is a positive fraction
3) bisectionSearch_3.py (small test)

    this create a program that guesses a secret number!
The program works as follows: you (the user) thinks of an integer between 0 (inclusive) and 100 (not inclusive). The computer makes guesses, and you give it input - is its guess too high or too low? Using bisection search, the computer will guess the user's secret number!

#### BISECTION SEARCH
the Bisection Search converges on the order of <img src="https://latex.codecogs.com/gif.latex?\inline&space;log_2&space;N" title="log_2 N" /></a> steps
Bisection Search works when value of function varies monotonically with input


1) decimalFractionToBinary.py

    turn a decimal fraction to its binary form. But if the frctions are not ones where the denominator is a whole power of 2, then the fraction cannot be represent exactly.   So we should use `abs(x-y) < epsilon` rather than `x==y` when compare two floats.

1) newtonRaphson.py

    Newton-Raphson Method to get an approximate root of number. It says that if g is an approxiamte root of x, then `g - p(g)/p'(g)` is a better answer.

### 2.2 Functions
So far, we've 
- covered language mechanism, the first notion of `while` and `for` loops, and therefore, of iterations.
- know how to write different files for each computation
- each file is some piece of code that saves away on the machine
- each code is a sequence of instructions
    
But, there're problems with this approach
- easy for small-scale problems
- messy for larger issues
- hard to keep track of details


**Function**: mechanism to achieve *decomposition* (sometimes called modularity) and *abstraction*

Analogy ：  a PROJECTOR
- it's a black box
- don't know how it works
- know the interface: input & output
- connect any electronics to it that can communicate with that input
- black box somehow converts image from input source to a wall or screen, magnifying it
- *ABSTRACTION*：do not need to know how projector works to use it 

Then if we want to produce a large image, we need more than one projectors
- all projectors work together to produce larger image
- *DECOMPOSITION* ：different devices work together to achieve an end goal

==>
*DECOMPOSITION* ： divide code into **modules**
- **self-contained** 
- used to **break up** code
- intended to be **reusable**
- keep code **organized**
- keep code **coherent**
*ABSTRACTION* ：suppress details of method to compute something from use off that computation
- think of a piece of code as a **black box**
- cannot see details
- do not need or want to see details
- hide tedious coding details
 
 **function** has a name, parameters(0 or more), a docstring(optional), a body
 ![Definition of Function](http://img.blog.csdn.net/20180111165535757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHNvb3R3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 #### ITERATIVE or RECURSIVE
 1) gcd.py
 
     use two ways(iterative / recursive) to find the greatest common divisor
 2) hanoi.py

    Tower of hanoi consists of three rods and some disks of different sizes, the object of the puzzle is to move the entire stack of disks to another rod, following some rules:<br>
    - Only one disk can be moved at a time
    - Each move consists of taking the upper disk from one stacks and placing it on the top of another stack
    - No disk may be placed on top of a smaller disk  
    Let's named the three rod of A, B and C, now we need to move n disks from A to C, and the program goes like:

    ```python
    def moveDisk(n, a, c):
        print('Move No.', n, 'disk from', str(a), 'to', str(c))

    def hanoi(n, a, c, b):
        '''
        input: move n disks from `a` to `c` in assist of `b`
        No. 1 disk is the smallest disk
        try to show the order of all the movement
        return: none
        '''
        if n == 1:
            moveDisk(1, a, c)
        else:
            hanoi(n - 1, a, b, c)  # move the n-1 tower from `a` to `b` in assist of `c`
            moveDisk(n, a, c)  # move No.n disk from `a` to `c`
            hanoi(n - 1, b, c, a)  # move the n-1 tower from `a` to `b` in assist of `c`

    hanoi(3, 'A', 'C', 'B')  # move 3 disk from A to C
    ```

 3) fibonacci.py

    calculate the total number of female rabbits after n month(s), take the prerequisites
    that at the beginning there are one male and one female rabbit in a pen that are immature to be pregnant, and it takes one month for them to give birth to two rabbits(male and female), and all the rabbits never die.

    So, when n=0(beginning), female=1; when n=1, female=1(pregnant); when n=2, female=2(one pregnant and another not)...

    The program goes like the following:

    ```python
    def fib(n):
        '''
        input: n represent the month
        return: the number of the total female after n mmonth(s)
        '''
        if n==0 or n==1:
            return 1
        else:
            # the number equals to the number one month earlier:fib(n-1)
            # plus the newborn rabbit that are the children of the fib(n-2) rabbits
            return fib(n-1)+fib(n-2)  
    ```

#### DIVIDE and CONQUER

Solve hard problems by breaking them into a set of sub-problems such that:
    - sub-problems are easier to solve than the original
    - solutions of the sub-problems can be combined to solve the original
1) palindrome.py

    test and show whether the input string is or not a palindrome
    an example of the divide and conquer algorithm


### Complete Programming Experience:polysum

A regular polygon has n number of sides. Each side has length s.<br>
The area of a regular polygon is:  <img src="https://latex.codecogs.com/gif.latex?\inline&space;\frac{0.25*n*s^2}{\tan(\pi&space;/n)}" title="\frac{0.25*n*s^2}{\tan(\pi /n)}" /><br>
The perimeter of a polygon is: length of the boundary of the polygon<br>
Write a function called `polysum` that takes 2 arguments, n and s. This function should sum the area and square of the perimeter of the regular polygon. The function returns the sum, rounded to 4 decimal places.

#### Credit Card Problems
1) getRemainingBalance.py

    calculate the remaining balance at the end of the year, using the given balance, annulInterestRate, monthlyPaymentRate
2) getLowestPayment.py
    
    calculate the lowest fixed monthly payment(should be the multiple of ten) to pay off the balance within 12 months
3) getLowestPaymentBisection.py 

    use bisection search to fast the program


## | Structured Types
### 3.1 Tuples and Lists
#### TUPLE
1) Introdution
    - An ordered sequence of elements, can mix element types
    - **immutable**, cannot change element values, cannot delete element(s) from the tuple, but can delete the whole tuple 
    - represented with parentheses, **()**
    - any object split with comma defaults to a tuple `t=1,2 #type(t) -> tuple`
    
    ```python
    te = ()     # empty tuple
    to = (0,)   # tuple with one element
    t = (2,"one",3)
    t[0]        # evaluates to 2
    (2,"one",3) + (5,)      # evaluates to (2,"one",3,5)
    t[1:2]      # slice tuple, evaluates to ("one",)
    t[1] = 4    # gives error, can't modify object
    del(te)      # delete the empty tuple `te`
    ```

2) Operators
    ```python
    (1,) + (2,3)    # (1,2,3)
    ('hi',)*4       # ('hi','hi','hi','hi')
    3 in (1,2,3)    # True
    for e in (1,2,3)
    ```

>tuple can be used to exchange two elements very fast: `x,y = y,x` or `(x,y) = (y,x)`
and thus tuple can be used to return more than one objects: `return (a, b, c)`

3) Functions

    - ~~cmp(t1, t2)~~  in py3, import operator and use operator.lt(a, b) operator.le(a, b) operator.eq(a, b) operator.ne(a, b) operator.ge(a, b) operator.gt(a, b)
    Only available when elements of t1, t2 are the same type, if one of the length of a tuple is less than another, it's smaller(Assume the former elements are the same) 
    - len(t)
    - sum(t)   # (should all be int or float)
    - max(t)   # get the max element of the tuple  `t`
    - min(t)
    - tuple(seq)    # turn the list, dictionary, set `seq` to tuple, if `seq` is dictionary, return the tuple of keys

#### LIST
1) Introdution
    - ordered sequence of information, which means accessible by index
    - a list is denoted by square brackets, **[]**
    - a list contains elements
     - usually homogeneous (i.e., all integers/all strings)
     - can contain mixed types(not common)
    - list is **mutable**

    ```python
    le = []     # empty list
    l = [2,"one",3,8,9,0]
    l[0]        # evaluates to 2
    l[1:2]      # slice list, evaluates to ["one"]
    l[1:4:2]    # slice list with some jump, evaluates to ["one",8]
    l[1] = 4    # list `l` turn out to be [2, 4, 3]
    l[2] + 2    # evaluate to 5

    - index can be a variable or expression, must evaluate to an int
    i = 2
    l[i-1]      # evaluate to 4, since l[1] is 4 from above
    ```

2) Operators
    ```python
    [1] + [2,3]    # [1,2,3]
    ['hi']*4       # ['hi','hi','hi','hi']
    3 in [1,2,3]   # True
    3 in [1,2,[3]] # False
    for e in [1,2,3]
    ```

3) Functions & Operations
    - len(l)
    - sum(l)   `# (should all be int or float)`
    - max(l)   `# get the max element of the list`
    - min(l)
    - list(seq)    `# turn the tuple, dictionary, set seq to list, if seq is dictionary, return the list of keys`

    ```python
    L = [1,2,5]
    L.append(7)    # list `L` turn out to be [1, 2, 5, 7]
    L.count(7)     # return the times that element 7 occurs in the list: 1
    L.extend(['new'])   # list `L` turn out to be [1, 2, 5, 7, 'new']
    L.index('new') # return 4, if `obj` is not in the list, gives error
    L.insert(0,'first') # list `L` turn out to be ['first', 1, 2, 5, 7, 'new']
    L.pop()        # default to remove the last element of the list, and return the removed element: 'new'
    L.pop(0)       # remove the element of index 0, thus return 'first'
    L.remove(7)    # remove the element 7, list `L` turn out to be [1, 2, 5]
    L.reverse()    # reverse the order of the list, list `L` turn out to be [5, 2, 1]
    L.sort()       # sort the elements of the list, list `L` turn out to be [1, 2, 5]
    sorted(L)      # sort the elements of the list, list `L` turn out to be [1, 2, 5] in the scope of global
    ```

### 3.2 Dictionaries and Sets
#### DICTIONARY
1) Introdution
    - store pairs of data (key : value)
    - a dictionary is denoted by curly braces, **{}**
    - `key` of dictionary is **immutable**(int,float,string,tuple,bool), since looking up the stored position of the `value` should depend on the hash value of the `key` ((actually need an hashable object, but think of as immutable as all immutable types are hashable)) **careful with float type as a key, might have an accuracy issue ||| careful with tuple type as a key, cause error when tuple contains mutable types**
    - `key` of dictionary is **unique**, only the last `value` of the same `key` will be stored
    - `value` of dictionary can be any type(immutable or mutable), even other dictionaries
    - `value` of dictionary can be duplicates
    - **no order** to keys and values
    - can insert and search very fast, not impeding by the amount of keys, but take up lots of memory

    ```python
    dict = {}
    dict = {1: 'a', 2: 'b', 3: 'c'}
    dict[4] = 'd'   # add an entry
    dict[4] = 'ddd' # change the value of key 4
    del(dict[4])    # delete an entry
    del(dict)       # delete the dictionary
    ```

2) Operators
    ```python
    3 in {1:'a',3:'c'}      # True
    'a' in {1:'a',3:'c'}    # False
    for key in dict.keys:   # same as  for key in dict:
    for value in dict.values():
    for key, value in dict.items():
    ```

3) Functions & Operations
    - len(d)
    - sum(d)   `# return the sum of the keys(should all be int or float)`
    - str(d)   `# output the string format of the dictionary d`

    ```python
    d = {'a':'apple'}
    dict = {1: 'a', 2: 'b', 3: 'c', 9: [1,2]}

    d.clear()   # clear all the elements of the dictionary d, after that d is an empty dictionary
    dict.get(2) # 'b', get value from key, if key is not in the dictionary, returns None
    dict.get(5,0) # if key(eg 5) isn't in the dictionary, then dict[5] will raise a KeyError, get(key, default) avoid the error by return the 2nd arg,  default 0

    dict.__contains__(2) # True if 2 is one of the keys

    #return the list of tuple element that contains each key and value pair
    dict.items() # dict_items([(1, 'a'), (2, 'b'), (3, 'c'), (9, [1,2])]),
    
    dict.keys() # dict_keys([1, 2, 3, 9])
    
    dict.values() # dict_values(['a', 'b', 'c', [1, 2]])
    
    # if key exists, return the value; else if key not exist & with no default value, 
    #the new key's value will be None; else the new value will be the 2nd arg
    dict.setdefault(key, default=None)  
    

    d2 = {4:'d'}
    dict.update(d2) # update the pair of key and value of d2 into dict
    pop_obj = dict.pop(4) # delete the item which key is 4, return the value of key 4: 'd', so pop_obj is 'd'
    pop_obj2 = dict.pop(6)  # if the key not exist, raise key error
    pop_obj3 = dict.pop(6, 'NotFound')  # if key not exist, and has the 2nd arg, then return the 2nd arg.  pop_obj3='NotFound'
    
    dict.popitem()  # delete one random pair of key and value, and return it as a tuple, like (1, 'a')
    

    # create a new dictionary which has the same number of elements in dict,
    # keys of newdict will be set as the seq given, seq can be list, tuple, dictionary, set;
    # if the 2nd arg is empty, all the value of newdict will be None, else all will be the value
    newdict = dict.fromkeys(seq[,value])    
    
    # ---------
    # direct assignment & copy & deep copy
    # direct assignment: dict2 is dict -> True
    # copy: dict3 and dict are different objs, but their subobjs(like list) point to the same obj
    # deep copy: not only dict4 and dict are different objs, their subobjs also point to different objs(completely independent)

    import copy
    dict = {1: 'a', 2: 'b', 9: [1,2]}
    dic2 = dict
    dict3 = dict.copy()
    dict4 = copy.deepcopy(dict)
    
    dict[1] = 'aa'
    dict[4] = 'd'
    dict[9].append(4)

    print(dict)     # {1: 'aa', 2: 'b', 4: 'd', 9: [1,2,4]}
    print(dict2)    # {1: 'aa', 2: 'b', 4: 'd', 9: [1,2,4]}
    print(dict3)    # {1: 'a', 2: 'b', 9: [1,2,4]}
    print(dict4)    # {1: 'a', 2: 'b', 9: [1,2]}
    ```

4) biggest.py

    small practice to use dictionary


#### SET
1) Introdution
    - like dictionary, only stores keys
    - elements are all unique and not ordered
    - can do some set operations
    - using `set()` to generate a set from a list, tuple, dictionary, set, string

    ```python
    se = set()    # an empty set, print(se) -> set()
    s = set([1,2])  # print(s) -> {1,2}
    s1 = set((1,3)) # print(s1) -> {1,3}
    s2 = set({1: 'a', 4: 'd'})  # print(s2) -> {1,4}
    s3 = set('hello')   # print(s3) -> {'o','h','l','e'}
    ```

2) Operators
    ```python
    a = set([0,2,4,6,8])
    b = set([0,1,2,3,5,7])
    ab = a & b          # print(ab) -> {0,2}
    ab2 = a | b         # print(ab2) -> {0,1,2,3,4,5,6,7,8}
    ab3 = a - b         # print(ab3) -> {8,4,6}
    ab4 = a ^ b         # print(ab) -> {1,3,4,5,6,7,8}
    2 in set([1,2,3])   # True
    for i in set([1,2,3])
    ```

3) Functions & Operations
    - len(s)
    - sum(s)    `# (should all be int or float)`
    - set(seq)  `# seq can be tuple, list, dictionary, set, string`

    ```python
    s = set([0,2,4,6])
    s1 = set([0,1,2,3])

    s.add(8)
    s1.update([5,7,11,13])
    s1.remove(13)   # s1.remove(99) will raise an error
    
    # remove one random element from s1, as elements are popped in the order they appear 
    # in the hash table, but its hash value can change
    s1.pop()    

    s1.discard(11)  # like remove(), but won't raise error when element doesn't exist
    s1.issubset(s)  # False, return True if s1 is the subset of s
    ss = s.intersection(s1)     # same as  ss = s & s1
    ss2 = s.union(s1)           # same as  ss2 = s | s1
    ss3 = s.difference(s1)      # same as ss3 = s - s1
    ss4 = s.symmetric_difference(s1)    # same as ss4 = s ^ s1
    s.clear()   # after that, s is an empty set
    ```

1) hangman.py
    
    hangman game

## | Midterm Exam
1) closest_power.py

    return the closest power of base**power to num, in case of a tie, return the smaller value
2) deep_reverse.py

    reverse the elements of the list L which elements are also list and reverse the elements of each elements of the list L
3) isCharInStr_bisectionSearch_recursive.py

    use bisection search to tell whether or not the char is in the alphabetized string aStr    
4) score.py

    return the score of the word, which is the result of applying fuction f to the scores of the word's two highest scoring letter


## | Good Programming
### 4.1 Testing and Debugging
#### BLACK-BOX TESTING and GLASS-BOX TESTING

Black-box testing is a method of software testing that tests the **functionality** of an application. Recall from the lecture that a way to think about black-box testing is to look at both:

- The possible paths through the **specification**.
- The possible **boundary** cases.
- Undoubtably many - if not all - of the listed tests look like they would be pretty good for testing the function size. However, we want you to think critically about the way size is specified - including possible boundary cases - and pick a set of tests that adequately and fully tests all paths and boundary conditions. Be sure the set of tests you pick does not have extraneous, useless, or repetitive tests.


A path-complete glass box test suite would find test cases that go through every possible path in the code. This is different from black-box testing, because in black-box testing you only have the function specification. For glass-box testing, you actually know how the function you are testing is defined. Thus you can use this definition to figure out how many different paths through the code exist, and then pick a test suite based on that knowledge.

#### BUGS
1) Runtime Bugs

    Overt vs. covert:<br>
    - **Overt** has an obvious manifestation - code crashes or runs forever
    - **Covert** has no obvious manifestation - code returns a value, which may be incorrect but hard to determine

    Persistent vs. intermittent:<br>
    - **Persistent** occurs every time code is run
    - **Intermittent** only occurs some  times, even if run on same input

2) Debugging

    - steep learning curve
    - goal is to have a bug-free program
    - tools
        - built in to IDE and Anaconda
        - Python Tutor
        - print statement
        - use your brain, be systematic in your hunt

    Logic Error(hard):
    - think before writing code
    - draw pictures, take break
    - explain code to some one else

    Steps:
    - study program code
        - ask how did I get the unexpected result
        - don't ask what is wrong
        - is it part of a family?
    - scientific method
        - study available data
        - form hypothesis
        - repeatable experiemnts
        - pick simplest input to test with
        
### 4.2 Exceptions and Assertions
#### EXCEPTIONS
1) Types
    
    Some types of exceptions: 
    - trying to access beyond list limits -> **IndexError**
    - using inexistent key of dictionary (dic['emp']) -> **KeyError**
    - referencing a non-existing variable, local or glabal name not found -> **NameError**
    - trying to convert an inappropriate type -> **TypeError**
    - mixing data types without coercion ( 'a'/4 ) -> **TypeError**
    - python can't parse program, trying to use keywords as a variable name -> **SyntaxError**
    - attribute reference fail, using inexistent attribute name of an object -> **AttributeError**
    - operand type okay, but value is illegal -> **ValueError**
    - IO system reports malfunction (e.g. file not found) -> **IOError**

2) What to do

    - fail silently: substitute default values or just continue; **bad idea!** cause user gets no warning
    - return an "error" value: complicates code have to check for a special value
    - stop execution, **signal error** condition: **raise an exception**

3) Dealing with Exceptions
    ```python
    try:
        a = int(input("Tell me one number:"))
        b = int(input("Tell me another number:"))
        print(a/b)
        print("Okay")
    except:
        print("Bug in user input.")
        print("Outside")
    ```

    Handling specific exceptions:
    ```python
    try:
        a = int(input("Tell me one number:"))
        b = int(input("Tell me another number:"))
        print("a/b = ", a/b)
        print("a+b = ", a+b)
    except ValueError:
        print("Could not convert to a number.")
    except ZeroDivisionError:
        print("Can't divide by zero.")
    except:
        print("Something went very wrong.")
    ```

4) Other Exceptions

    - **else**: Executed when execution of associated **try** body completes with no exceptions
    - **finally**: Always executed after **try**, **else**, **except** clauses, even if they (raised another error) or (executed a **break**, **continue**, **return**)    [useful for clean-up code that should be run no matter what else happened, like 'close a file']

5) Using Exceptions

    - **raise**, control when to raise an exception by users, and program skips the next lines(same indentation): `e.g. raise ValueError('error')`
    see --> get_ratio.py

    ```python
    while True:
        try:
            n = input("Please enter an integer:")
            n = int(n)
            break
        except ValueError:
            print("Input not a integer; try again")
    print("Correct input of an integer~")
    ```

    ```python
    data = []
    file_name = input("Provide a name of a file of data")

    try:
        fh = open(file_name, 'r')
    except IOError:
        print('cannot open', file_name)
    else:
        for new in fh:
            if new != '\n':
                addIt = new[:-1].split(',') # remove trailing \n
                data.append(addIt)
    finally:
        fh.close() # close file even if fail

    gradeData = []
    if data:
        for student in data:
            try:
                name = student[0:-1]
                grades = int(student[-1])
                gradeData.append([name, [grades]])
            except ValueError:
                gradeData.append([student[:], []])
    ```

#### ASSERTIONS
1) Introduction
    
    - want to be sure that assumptions on state of computation are as expected
    - use an **assert** statement to raise an **AssertionError** exception if assumptions not met
    - an example of good defensive programming

    ```python
    def avg(grades): 
        '''
        Assumes: grades is a collection
        if the length of grades is 0, then throw out the message: no grades data;
        else return the average of the grades 
        '''
        assert not len(grades) == 0, 'no grades data'
        return sum(grades) / len(grades)
    ```

    - Features:
        - assertions don't allow a programmer to control response to unexpected conditions
        - ensure that execution **halts** whenever an expected condition isn't met
        - typically used to **check inputs** to functions procedures, but can be used anywhere
        - can be used to **check outputs** of a function to avoid propagaring bad values
        - can make it easier to locate a source of a bug

2) Where to use
    
    - goal is to spot bugs as soon as introduced and make clear where they happened
    - use as a supplement to **testing**
    - **raise exceptions** if users supplies bad data input 
    - use assertions to
        - check **types** if arguments or values
        - check that **invariants** on data structures are met
        - check **constraints** on return values
        - check for **violations** of constraints on procedure(e.g. no duplicates in a list)

## | Object Oriented Programming
### 5.1 Classes and Inheritance
#### Object Oriented Programming(OOP)
1) Object
    - features: each object has 
        - a **type**
        - an internal **data representation** (primitive or composite)
        - a set of procedures for **ineraction** with the object
    - each instance is a particular type of object
        - eg. 123 is an instance of an **int**
        - str0 = "hello"  --> str0 is an instance of a **string** 

    - objects are a **data abstraciton** that capture:
        - internal **representation** through data attributes
        - **interface** for interacting with object through methods(procedures), defines behaviors but hides implementation
    - can **create new instances** of objects
    - can **destroy objects**
        - explicitly using **del** 
        - or just "forget" about them: Python system will reclaim destroyed or inaccessible objects --- called "grabage collection"

2) User Defined Objects with Classes
    - creating the class involves:
        - defining the class name
        - defining class atttributes
    - using the class involves:
        - creating new instances of objects
        - doing operations on the instances

3) Advantages of OOP
    - **bundke data into packages** together with procedures that work on them through well-defined interfaces
    - **devide-and-conquer** development
        - implement and test behavior of each class separately
        - increased modularity reduces complexity
    - classes make it easy to **reuse** code
    - classes make it easy to **reuse** code
        - many Python medules define new classes
        - each class has separate environment(no collision on function names)
        - inheritance allows subclasses to redefine or extend a selected subset of a superclass' behavior


#### Class Instance
1) Define Own Types
    - use **class** keyword to define a new type:
    ```python
    class Coordinate(object):
        #<define attributes here>
    ```

    - similiar to **def**, indent code to indicate which statements are part of the class definition
    - the word **object** means that **Coordinate** is a Python object and inherits all its attributes(coming soon)
        - **Coordinate** is a subclass of **object**
        - **object** is a superclass of **Coordinate** 

2) Attributes
    - data and procedures that belong to the class
    - **data** attributes:
        - think of data as other objects that make up the class
        - eg. an coordinate is made up of two numbers
    - procedural attributes(**methods**)
        - think of methods as functions that only work with this class
        - eg. you can define a distance between two coordinate objects but there is no meaning to a distance between two list objects

3) Defining How to Create an Instance of a Class
    - using a special method called **__init__** to initialize some data attributes

    ```python
    class Coordinate(object):
        def __init__(self, x, y):
        """
        self : parameter to refer to an instance of the class
        x, y : what data initializes a **Coordinate** object
        self.x, self.y : two data attributes for every **Coordinate** object
        """
            self.x = x
            self.y = y
    ```

#### Methods
1) Definition
    - procedural attribute, like a function that works only with this class
    - python always passes the actual object as the first atgument, convention is to use **self** as the name of the first atgument of all methods
    - the . operator is used to access any attribute: a **data** attributeof an object or a **method** of an object

2) Eg for Define a Method for Class

    ```python
    class Coordinate(object):
        def __init__(self, x, y):
            self.x = x
            self.y = y
        def distance(self, other):
            x_diff_sq = (self.x-other.x)**2
            y_diff_sq = (self.y-other.y)**2
            return (x_diff_sq + y_diff_sq)**0.5


    c= Coordinate(3,4)
    origin = Coordinate(0,0)
    print(c.distance(origin)) # shows 5.0
    print(Coordinate(c, origin)) # also shows 5.0, equivalent to the previous one
    ```
    - think of **Coordinate** as pointing to a frame:
        - within the scope of that frame we created methods
        - **Coordiante.distance** gets the value of **Coordiante (a frame)**, then looks up the value associated with **distance (a procedure)**, the invokes it(which requires two arguments)
        - **c.distance** inherits the **distance** from the class definition, and automatically use the **c** as the first atgument

3) Print Representation of an Object
    - use print(instance) method would give out **uninformative** result
    - should define a **__str__** method for a class
    - Python calls the **__str__** method when uesd with print on the class object
    - you choose what it does! Say that when we print a **Coordinate** object, want to show: <3,4>
    - eg:

    ```python
        def __str__(self):
            return "<"+ str(self.x) + "," + str(self.y) + ">"

    print(c) # it shows <3,4>
    ```

4) Wrapping your Head Around Types and Class
    ```python
        print(type(c)) #it shows <class __main__.Coordinate>
        print(Coordinate) # it also shows <class __main__.Coordinate>
        print(type(Coordinate)) # it shows <type 'type'> 

        #can use isinstance() to check if an object is an instance of a class
        print(isinstance(c, Coordinate)) # it returns True
    ```

5) Special Operators
    - +, -, <, >, len(), print, and many others
    - refer to: [https://docs.python.org/2/reference/datamodel.html#basic-customization](https://docs.python.org/2/reference/datamodel.html#basic-customization)
    - like print, can override these to work with your class
    - define them with double underscores before & after
        - __add__(self, other) -> self + other
        - __sub__(self, other) -> self - other
        - __eq__(self, other) -> self == other
        - __lt__(self, other) -> self < other
        - __len__(self) -> len(self)
        - __str__(self) -> print(self)
        and others...
    - eg:

    ```python
        def __sub__(self, other):
            return Coordinate(self.x - other.x, self.y - other.y)

    foo = c.sub(origin)
    print(foo) # it shows <3,4> , since we defined __str__ method before
    ```


#### Class Examples
1) Example: Fraction
    - create a **new type** to represent an number as a fraction
    - **internal representation** is two integer:
        - numerator # top
        - denominator # under
    - **interface** a.k.a.(also known as) **methods** a.k.a. **how to interact** with **Fraction** objects
        - print representation
        - add, substract
        - convert to a float

2) Initial Fraction Class
    ```python
    class fraction(object):
        def __init__(self, numer, denom):
            self.numer = numer
            self.denom = denom
        def __str__(self):
            return str(self.numer) + '/' + str(self.denom)
    ```

3) Accessing Data Attributes
    ```python
    class fraction(object):
        def __init__(self, numer, denom):
            self.numer = numer
            self.denom = denom
        def __str__(self):
            return str(self.numer) + '/' + str(self.denom)
        def getNumer(self):
            return self.numer
        def getDenom(self):
            return self.denom

    onHalf = fraction(1,2)
    twoThirds = fraction(2,3)
    print(oneHalf) # it shows 1/2
    print(onHalf.getNumer()) # it shows 1
    print(fraction.getDenom(twoTirds)) # it shows 3 
    ```

    - adding other methods:
    ```python
        def __add__(self, other):
            newNumer = other.getDenom() * self.getNumer() + other.getNumer() * self.getDenom()
            newDenom = self.getDenom() * other.getDenom()
            return fraction(newNumer, newDenom)
        def __sub__(self, other):
            newNumer = other.getDenom() * self.getNumer() - other.getNumer() * self.getDenom()
            newDenom = other.getDenom() * self.getDenom()
            return fraction(newNumer, newDenom)
        def convert(self):
            return self.getNumer() / self.getDenom()

    oneHalf = fraction(1,2)
    twoThirds = fraction(2,3)
    newFraction = oneHalf + twoThirds
    print(newFraction)
    ```

4) Example: a set of Integer
    - create a new type to represent a collection of integers
        - initially the set is empty
        - a particular integer appears only once in a set: called 
         **representational invariant** enforced by the code
    - internal data representation
        - use a **list** to store the elements of a set
    - **interface**
        - insert(e)     -> insert integer e into set if not there
        - member(e)     -> return True if integer e is in set, Flase else
        - remove(e)     -> remove integer e from set, error if not presenth
    - eg:

    ```python
    class intSet(object):
        def __init__(self):
            self.vals = []
        def insert(self, e):
            if ont e in self.vals:
                self.vals.append(e)
        def member(self, e):
            retrun e in self.vals
        def remove(self, e):
            try:
                self.vals.remove(e)
            except:
                raise ValueError(str(e) + "not found")
        def __str__(self):
            self.vals.sort()
            result = ''
            for e in self.vals:
                result = result + str(e) + ","
            return "{" + result[:-1] + "}"
    
    s = intSet()
    print(s) # it shows {}
    s.insert(2)
    s.insert(3)
    s.insert(2)
    print(s) # it shows {2,3}
    s.member(3) # it shows True
    s.remove(2)
    print(s) # it shows {3}

    # it raises an self-defined error -> ValueError: 3 not found   
    # following by the system defined error -> ValuError: list.remove(x): x not in list
    s.remove(2) 
    ```


#### Why OOP
1) The Power of OOP
    - **bundle together objects** that share:
        - common attributes and
        - procedures that operate on those attributes
    - use **abstraction** to make a distinctoin between how to implememt an object VS how to use the object
    - build **layers** of object abstraction that inherit behaviors from other classes of objects
    - create our **own classes of objects** on top of Python's basic classes

2) Implementing the class VS Using the class
    - write code from two different perspectives
    - all class examples we saw so far were numerical

    - Implememting a new object type with a class:
        - define the class
        - define data attributes (what is the object)
        - define methods(how to use the object)
    - Using the new object type in code:
        - create instances of the object type
        - do operations woth them

3) Class definition of an object type VS Instance of a class
    - class is the **type**
        - a ***Coordinate*** type : `class Coordinate(object):`
    - class id defined generically
        - use ***self*** to refer ro any instance while defining the class
    - class defines data and methods **common across all instances**

    - instance is **one particular** object
        - `mycoo = Coordinate(3,4)`
    - data values vary between instances
        - `c1 = Coordinate(1,2)`
        - `c2 = Coordinate(3,4)`
        - c1 and c2 have differnert data values because they are different objects
    - instance has the **structure of the class**

4)Why use OOP and Classes of Objects
    - mimic real life
    - group different objects as part of the same type

5) Groups of Objects have Attributes
    - **data attributes**:
        - how can you represent your object with data?
        - **what it is**
        - <for a coordinate:x and y values>
        - <for an animal:age, name>
    - **procedural attributes**(behaviors/ operations/ methods):
        - what kind of things can you do with the object?
        - **what it does**
        - <for a coordinate:find distance between two>
        - <for an animal:make a sound>

6) Defining a Class(Recap)
    - `name` is a data attribute even though an instance is not initialized with it as a parameter
    ```python
    class Animal(object):
        def __init__(self, age):
            self.age = age
            self.name = None

    myanimal = Animal(3)
    ```

7) Getter and Setter Methods
    ```python
    class Animal(object):
        def __init__(self, age):
            self.age = age
            self.name = None
        def get_age(self):
            return self.age
        def get_name(self):
            return self.name
        def set_age(self, newage):
            self.age = newage
        def set_name(self, newname=""): 
            self.name = newname
        def __str__(self):
            return "animal:" + str(self.name) + ":" + str(self.age)
    ```
    - **default arguments** for formal parameters are used if no actual argument is given:
        - for the method: `def set_name(self, newname=""):`
            - default argument used here: `myanimal.set_name()`
            - argument passed is used here: `myanimal.set_name('fluffy')`

8) Information Hiding
    - dot notation used to access the attributes(data and methods) though it is better to use getters and setters to access data attributes:
        - `myanimal.age` (access the data attribute)
        - **Better** : `myanimal.get_age()` (access and use method [if just call myanimal.get_age, get method but don't invoke it])

    - Thus, author of class definition may **change data attribute** variable names:
    ```python
    class Animal(object):
        def __init(self, age):
            self.years = age
        def get_age(self):
            return self.years
    ```

    - if you are accessing data attributes outside the class and class definition changes, may get errors
    - outside of class, use **getter and setter** instead: USE ***myanimal.get_age()*** NOT ***myanimal.age***
        - good style
        - easy to maintain code
        - prevent bugs

9) Python not Great at Information Hiding
     - allows you to **access data** from outside class definition `print(myanimal.age)`
     - allows you to **write to data** from outside class definition `myanimal.age = 'infinite'`
     - allows you to **create data attributes** for an instance from outside class definition `myanimal.size = 'tiny'`
     - it's **not good style** to do any of these!!!



#### Hierarchies
1) Hierarchies
    - parent class(superclass)
    - child class(subclass)
         - inherit all data and behaviors of parent class
         - **add new information**
         - **add new behaviors**
         - **override behaviors**

2) Inheritance
    - add new functionality with `speak()`
        - instance of type `Cat` can be called woth new methods
        - instance of type `Animal` throws error if called with new methods
    - `__init__` isn't missing, uses the Animal version
    
    ```python
    class Cat(Animal):
        def speak(self): # new method
            print("meow")
        def __str__(self): # override
            return "cat:"+str(self.name)+":"+str(self.age)

    cat1=Cat(2)
    cat1.set_name('jelly')
    print(cat1) # it shows cat:jelly:2
    print(Animal.__str__(cat1)) # it shows animal:jelly:2 
    ```

3) Which method to use
    - subclass can have **methods with same name** as superclass
    - subclass can have **methods with same name** as other subclass(they are the same level)
    - for an instance of a class, look for a mehod name in **current class definition**
         - if not found, look for method name **up the hierarchy**(inparent, then grandparent, and so on)
         - use first method up the hierarchy that you found with that method name

4)
    ```python
    class Person(Animal):
        def __init__(self, name, age):
            Animal.__init__(self, age) # call Animal constructor
            Animal.set_name(self, name) # call Animal's method
            self.friends = []
        def get_friends(self):
            return self.friends
        def add_friends(self, fname):
            if fname not in self.friends:
                self.friends.append(fname)
        def speak(self):
            print("hello")
        def age_diff(self, other):
            # alternate way: diff = self.age - other.age
            diff = self.get_age() - other.get_age()
            if self.age > other.age:
                print(self.name, "is", diff, "years older than", other.name)
            else:
                print(self.name, "is", diff, "years younger than", other.name)
        def __str__(self):
            return "person:"+str(self.name)+":"+str(self.age)
    
    import random

    class Student(Person):
        def __init__(self, name, age, major=None):
            Person.__init__(self, name, age)
            self.major = major
        def change_major(self, major):
            self.major = major
        def speak(self):
            r = random.random() # gives back float between [0,1)
            if r < 0.25:
                print("i have homework")
            elif 0.25 <= r < 0.5:
                print("i need sleep")
            elif 0.5 <= r <0.75:
                print("i should eat")
            else:
                print("i am watching tv")
        def __str__(self):
            return "student:"+str(self.name)+":"+str(self.age)+":"+str(self.major)
    ```


#### Class Variables
1) Instance Variables VS Class Variables
    - Instance Variables:
        - we have seen instance variables so far in code
        - specific to an instance
        - created for **each instance**, belongs to an instance
        - used the generic variable name `self` within the class definition:  `self.variable_name`
    - Class Variables:
        - introduce class variables that belongs to the class
        - defined inside class but outside any class methods, outside `__init__`
        - **shared** among all objects/instances of that class

2) Class Variables and the ***Rabbit*** Subclass
    - **subclass inherit** all data attributes and methods of the parent class
    - `tag`(class variable) uesd to give **unique id** to each new rabbit instance
    - define **+ operator** between two `Rabbit` instances
        - define what something like this does: r4 = r1 + r2
        - where r1 and r2 are `Rabbit` instances
        - r4 is a new `Rabbit` instance with age 0
        - r4 has `self` as one parent and `other` as the other parent
        - in __init__, should change to check that **parent1 and parent2 are of type Rabbit**
    - define __eq__ to compare two Rabbits
        - comparing ids of parents since rid are unique(due to class var)
        - note that comparing objects(`self.parent1 == other.parent1`) will call the __eq__ method over and over until call it on None, thus will get **AttributeError**

    ```python
    class Rabbit(Animal):
        tag = 1
        def __init__(self, age, parent1=None, parent2=None):
            Animal.__init__(self, age)
            self.parent1 = parent1
            self.parent2 = parent2
            self.rid = Rabbit.tag
            Rabbit.tag += 1
        def get_rid(self):
            # zfill(num) is a method on a string to pad the beginning with zores
            return str(self.rid).zfill(3) # eg. return 001 instead of 1
        def get_parent1(self):
            return self.parent1
        def get_parent2(self):
            return self.parent2
        def __add__(self, other):
            # returning object of same type as this class, means the child of self and other
            return Rabbit(0, self, other)
        def __eq__(self, other):
            # decide two rabbits are equal if they have the same two parents
            parents_same = self.parent1.rid == other.parent1.rid and self.parent2.rid == other.parent2.rid
            parent_opposite = self.parent2.rid == other.parent1.rid and self.parent1.rid ==other.parent2.rid
            return parent_same or parent_opposite
    ```



### 5.2 An Extended Example
#### Building a Class
1) Using Inheritance
    - explore in some detail an example of buildingan application that organization that organize info about people
    - start with a Person object
         - Person: name, birthday
            - get last name
            - sort by last name
            - get age
    
    ```python
    import datetime

    class Person(object):
        def __init__(self, name):
            """create a person called name"""
            self.name = name
            self.birthday = None
            self.lastName = name.split(' ')[-1]
        def getLastName(self):
            """return self's last name"""
            return self.lastName
        def __str__(self):
            """return self's name"""
            return self.name
        def setBirthday(self, month, day, year):
            """sets self's birthday to birthDate"""
            self.birthday = datetime.date(year, month, day)
        def getAge(self):
            """return self's current age in days"""
            if self.birthday == None:
                raise ValueError
            return (datetime.date.today() - self.birthday).days
        def __lt__(self, other):
            """return True if self's name is lexicographically less than other's name,
            and False otherwise"""
            if self.lastName == other.lastName:
                return self.name < other.name
            return self.lastName < other.lastName

    p1 = Person('Mark Zuckerburg')
    p1.setBirthday(5,14,84)
    p2 = Person('Drew Houston')
    p2.setBirthday(3,4,83)
    p3 = Person('Bill Gates')
    p3.setBirthday(10,28,55)
    p4 = Person('Andrew Gates')
    p5 = Person('Steve Wozniak')

    personList = [p1, p2, p3, p4, p5]

    for e in personList:
        print(e) 
    # shows Mark Zuckerburg, Drew Houston, Bill Gates, Andrew Gates, Steve Wozniak in each line

    personList.sort()
    print()

    for e in personList:
        print(e)
    # shows Andrew Gates, Bill Gates, Drew Houston, Steve Wozniak, Mark Zuckerburg in each line
    ```

#### Visualizing the Hierarchy
1) Using Inheritance
    - explore in some detail an example of buildingan application that organization that organize info about people
    - start with a Person object
         - Person: name, birthday
            - get last name
            - sort by last name
            - get age
    - MITPerson: Person + ID Number
        - assign ID number in sequence
        - get ID number
        - sort by ID number
    ```python
    class MITPerson(Person):
        nextIdNum = 0 # next ID number to assign

        def __init__(self, name):
            Person.__init__(self, name) # initialize Person attributes
            self.idNum = MITPerson.nextIdNum # MITPerson attribute:unique ID
            MITPerson.nextIdNum += 1
        def getIdNum(self):
            return self.idNum

        def __lt__(self, other):
            # sorting MIT people uses their ID number, not name!
            return self.idNum < other.idNum
        def speak(self, utterance):
            return (self.getLastName() + " says: " + utterance)

    m3 = MITPerson('Mark Zuckerburg')
    Person.setBirthday(m3,5,14,84)
    m2 = MITPerson('Drew Houston')
    Person.setBirthday(m2,3,4,83)
    m1 = MITPerson('Bill Gates')
    Person.setBirthday(m1,10,28,55)

    MITPersonList = [m1,m2,m3]

    for e in MITPerson:
        print(e)
    # shows Bill Gates, Drew Houston, Mark Zuckerburg in each line

    MITPerson.sort()
    print()

    for e in MITPerson:
        print(e)
    # shows Mark Zuckerburg, Drew Houston, Bill Gates in each line(sorting by ID) 
    ```

2) How to Compare?

    ```python
    mp1 = MITPerson('Eric')
    mp2 = MITPerson('John')
    mp3 = MITPerson('John')
    mp4 = Person('John')

    mp1 < mp2 # shows True
    mp4 < mp1 # shows Flase (WHY???!!!)
    mp1 < mp4 # shows AttributeError: 'Person' object has no attribute 'idNum'
    ```

    - MITPerson has its own ***__lt__*** method
    - method "shadows" the **Person** method, meaning that if we compare an MITPerson object. since its environment inherits from the **MITPerson** class environment, Python will see this version of ***__lt__*** not the ***Person*** version
    - thus, `mp1 < mp2` will be converted into `mp1.__lt__(mp2)` which applies the method associated with the type of `mp1`, or the MITPerson version
    - Why does mp4 < mp1 work, but mp1 < mp4 doesn't?
         - mp4 < mp1 is equivalent to mp4.__lt(mp1), which means we use the __lt__ method associated with the type of mp4, namely a Person(the one that compares based on name)
         - mp1 < mp4 is equivalent to mp1.__lt__(mp4), which means we use the __lt__ method associated with the type of mp1, namely an MITPerson and since mp4 is a Person, it doesn't have an attribute 'idNum'

#### Adding another class
1) Using Hieritance
    - explore in some detail an example of building an application that organizes info about perple
        - Person: name, birthday
            - get last name
            - sort by name
            - get age
        - MITPerson: Person + ID Number
            - assign ID Number in sequence
            - get ID number
            - sort by ID number
        - Student: several types, all MITPerson
            - undergraduate student: has class year
            - graduate student (can't tell how long it's going to finish up their PhD)

    ```python
    class UG(MITPerson):
        def __init__(self, name, classYear):
            MITPerson.__init__(self, name)
            self.year = classYear
        def getClass(self):
            return self.year
        def speak(self, utterance):
            return MITPerson.speak(self, "Dude, " + utterance)

    class Grad(MITPerson):
        pass

    def isStudent(obj):
        return isinstance(obj, UG) or isinstance(obj, Grad)


    s1 = UG('Matt Damon', 2017)
    s2 = UG('Ben Affleck', 2017)
    s3 = UG('Lin Manuel Miranda', 2018)
    s4 = Grad('Leonardo di Caprio')

    studentList = [s1,s2,s3,s4]

    print(s1) # shows Matt Damon
    print(s1.getClass()) # shows 2017
    print(s1.speak('where is the quiz?')) # shows Damon says: Dude, where is the quiz?
    ```

2) Cleaning up Hierarchy
    - there is another type of student, `TransferStudent`, somebody who comes to MIT after a year of being somewhere else
    - But there is a problem, we should to rethink isStudent method (return isinstance(obj,UG) or isinstance(obj,Grad) or isinstance(obj,TransferStudent) )
    - A cleaner way to change it: actually there is an implicit class here --- Student
    ```python
    class Student(MITPerson):
        pass

    class UG(Student):
        def __init__(self, name, classYear):
            MITPerson.__init__(self, name)
            self.year = classYear
        def getClass(self):
            return self.year
        def speak(self, utterance):
            return MITPerson.speak(self, "Dude, " + utterance)

    class Grad(Student):
        pass

    class TransferStudent(Student):
        pass

    def isStudent(obj):
        return isinstance(obj, Student)
    ```

#### Using Inherited Method
1) Using Inherited Methoduse
     - add a Professor class of object
        - also a kind of MITPerson
        - but has different behaviors
    - use as an example to see how one can leverage methods from other classes in the hierarchy but use that modularity to isolate changes to methods when we want to

    ```python
    class Professor(MITPerson):
        def __init__(self, name, department):
            MITPerson.__init__(self, name)
            self.department = department
        def speak(self, utterance):
            new = 'In course ' + self.department + ' we say '
            return MITPerson.speak(self, new + utterance)
        def lecture(self, topic):
            return self.speak('it is obvious that ' + topic)

    faculty = Professor('Doctor Arrogant', 'six')

    print(faculty.speak('hi there')) # shows Arrogant says: In course six we say hi there
    print(faculty.lecture('hi there')) # shows Arrogant says: In course six we say it is obvious that hi there
    ```

2) Modularity Helps
    - by isolating methods in classes, makes it easier to change behaviors
        - can change base behavior of MITPerson class, which will be inherited by all other subclasses of MITPerson
        - or can change behavior of a lower class in hierarchy
    - for example, change MITPerson's speak method to:
    ```python
    def speak(self, utterance):
        return  (self.name + "says:" + utterance)
    ```
    - then, all the MITPerson and its subclasses's speak methods, would use the person's full name rather than just its last name


#### Gradebook Example
1) Example Class: Gradebook
    - create class that includes instances of other classes within it
    - concept:
        - build a data structure that can hold grades for students
        - gather together sata and procedures for dealing with them in a single structure, so that users can manipulate without having to know internal details
    ```python 
    class Grades(object):
        """A mapping from students to a list of grades"""
        def __init__(self):
            """Create empty grade book"""
            self.students = [] # list of Student objects
            self.grades = {} # maps isNum -> list of grades
            self.isSorted = True

        def addStudent(self, student):
            """Assumes: student is of type Student
                Add student to the grade book"""
            if student in self.students:
                raise ValueError('Duplicate student')
            self.students.append(student)
            self.grades[student.getIdNum()] = []
            self.isSorted = False

        def addGrade(self, student, grade):
            """Assumes: grade is a float
            Add grade to the list of grades fprstudent"""
            try:
                self.grades[student.getIdNum()].append(grade)
            except KeyError:
                raise ValueError('Student not in grade book') 

        def getGrades(self, student):
            """Return a list of grades for student"""
            try:
                #Important!!!  return a copy of grade, using [:]
                return self.grades[student.getIdNum()][:]
            except KeyError:
                raise ValueError('Student not in grade book')

        def allStudents(self):
            """Return a list of the students in the grade book"""
            if not self.isSorted:
                self.students.sort()
                self.isSorted = True
            return self.students[:] # return copy of list of student

    def gradeReport(course):
        """Assumes: course is of type Grades"""
        report = []
        for s in course.allStudents():
            tot = 0.0
            numGrades = 0
            for g in course.getGrades(s):
                tot += g
                numGrades += 1
            try:
                average = tot/numGrades
                report.append(str(s) + '\'s mean grade is ' + str(average))
            except ZeroDivisionError:
                report.append(str(s) + 'has no grades')
        return '\n'.join(report)


    ug1 = UG('Matt Damon', 2018)
    ug2 = UG('Ben Affleck', 2019)
    ug3 = UG('Drew Houston', 2017)
    ug4 = UG('Mark Zuckerberg', 2017)
    g1 = Grad('Bill Gates')
    g2 = Grad('Steve Wozniak')

    six00 = Grades()
    six00.addStudent(g1)
    six00.addStudent(ug2)
    six00.addStudent(ug1)
    six00.addStudent(g2)
    six00.addStudent(ug4)
    six00.addStudent(ug3)


    six00.addGrade(g1, 100)
    six00.addGrade(g2, 25)
    six00.addGrade(ug1, 95)
    six00.addGrade(ug2, 85)
    six00.addGrade(ug3, 75)

    print(gradeReport(six00)) # first report based on the initial grades

    six00.addGrade(g1, 90)
    six00.addGrade(g2, 45)
    six00.addGrade(ug1, 80)
    six00.addGrade(ug2, 75)

    print()
    print(gradeReport(six00)) # modified grade report based on all the grades
    ```

2) Using Example
    - could list all student using: `for s in sixx00.allStudents():`
    - prints out the list of student names sorted by idNum
    - why not just do: `for s in six00.students:`
    - violates the data hiding aspect of an object, and exposes internal representation
        - if I were to change how I want to represent a grade book, I should only need to change the methods within that object, not external procedures that use it

3) Comments on Example
    - nicely separeates collection of data from use of data
    - access is through methods associated with the gradebook object
    - but current version is inefficient - to get a list of all students, I create a copy of the internal list
        - let's me manipulate without change the internal structure
        - but expensive in a MOOC(Massive Open Online Course) with 100,000 students, it's bad idea to generate a list of 100,000 long


#### Generators
1) Generators
    - any procedure or method with `yield` statement called a **generator**
    ```python
    def genTest():
        yield 1
        yield 2

    foo = genTest()
    print(foo.__next__()) # shows 1
    print(foo.__next__()) # shows 2
    print(foo.__next__()) # raise a StopIteration Error
    ```
    - `genTest()` --> <generator object genTest at 0x201b878> but not the general fuction
    - generators have a `next()` method which starts/resumes execution of the procedure. Inside of generator:
         - `yield` suspends execution and returns a value
          - reutrn from a generator raises a StopIteration exception

2) Fancier Example
    ```python
    def genFib():
        fibn_1 = 1 # fib(n-1)
        fibn_2 = 0 # fib(n-2)
        while True:
            # fib(n) = fib(n-1) + fib(n-2)
            next = fibn_1 + fibn_2
            yield next
            fibn_2 = fibn_1
            fibn_1 = next

    fib = genFib()
    print(fib) # shows <generator object genTest at 0x11bfd3620>

    print(fib.__next__()) # shows 1
    print(fib.__next__()) # shows 2
    print(fib.__next__()) # shows 3
    print(fib.__next__()) # shows 5
    print(fib.__next__()) # shows 8
    ```

     - evaluating `fib = genFib()` cretes a generator object
     - calling `fib.__next__()` will return the first Fabonacci number, and the subsequence call will generate each number in sequence
     - evaluating `for n in genFib():` with next line ` print(n)` will procedure all of the Fibonacci numbers(an infinite sequence)

3) Why Generator
     - generator separates the concept of computing a very long sequence of objects, from the actual process of computing them explicitly
     - allows one to generate each new objects as needed as part of another computation(rather than computing a very long sequence, only to throw most of it away while you do something on an element, then repeating the process)
     - have already seen this idea in `range(n)`

4) Fix the Former Grades Class
    ```python
    def allStudent(self):
        """Before"""
        if not self.isSorted:
            self.students.sort()
            self.isSorted = True
        return self.students[:] # return copy of list of students


    def allStudents(self):
        """After"""
        if not self.isSorted:
            self.students.sort()
            self.isSorted = True
        for s in self.students:
            yield s
    ```

5) genPrimes(Exercise)
    - Write a generator, genPrimes, that returns the sequence of prime numbers on successive calls to its next() method: 2, 3, 5, 7, 11, ...
    - Tips: Have the generator keep a list of the primes it's generated. A candidate number x is prime if `(x % p) != 0` for all earlier primes p.
    
    ```python
    def genPrimes(x = 1):
        primesList = [2]
        yield 2
        while True:
            #x += 1
            x += 2 # more efficient
            for p in primesList:
                if x % p == 0:
                    break
            else: 
            # executed only when the primeList is exhausted, but when the loop break,
            # it won't executed
                primesList.append(x)
                yield x

    def genPrimes2(x = 1):
        """Another good code sample"""
        primesList = [2]
        yield 2
        while True:
            x += 2
            if all(x%p != 0 for p in primesList):
            """all(iterable) method only returns True if 
            each element of the para iterable is True(False when 
            the element is Flase, or 0, or empty)
            Notice: all([]) or all(()) returns True"""
                yield x
                primesList.append(x)

        ```


6) Some Conceptions Needed Attention
    - Every procedure that has a `yield` statement is a generator.
    - Everything that can be done with generator can be done with a function. But, sometimes a generator is a better choice because we can ask the generator for the next item, one at a time, and don't waste the time computing values that we don't ultimately want(or won't want for a long time)
    - A procedure is still a generator even though the `yield` statement in it will never be executed.
    - If we were to use a generator to iterate over a million numbers, how many numbers do we need to store in memory at once? **2 !** (one is the current value, another is the max value-->1000000) ***# Python actually provides this! The range function is a generator.***

    - Generator or Standard fuction works best***(least memory use & least cpu use)*** in the following conditions: 
        - Finding the nth Fibonacci number : **Standard fuction**
            - There are formulas to calculate the nth Fibonacci number. A function could implement this so no looping/iterating is necessary
            ```python

        - Printing out an unbounded sequence of Fibonacci numbers: **Generator**
            - 
        - Printing out a bounded sequence of prime numbers, where the prime numbers are successively computed by division by smaller primes: **Either is fine**
            - both of them can show the result, and even the code of the two ways look same(See ***primesGenerator.py*** the function `genPrimesFn()` and the generator `genPrimesFn2()`)
        - Printing out an unbounded sequence of prime numbers, where the prime numbers are successively computed by division by smaller primes: **Generator**
            - 
        - Finding the score of a word from the ProblemSet4:6.00 word game(make up words as much as u could from a bundle of letters): **Standard function**
            - Only one result returned, so short that savings from generator don't overweigh the overhead(See the `findScore()` function in ***ps4a.py***)
        - Iterating over a sequence of numbers in a random order, where no number is repeated: **Standard function**
            -  Its the random order which requires you to maintain the whole list in memory so you don't save anything by going to a generator.




## | Algorithmic Complexity
### 6.1 Computational Complexity

### 6.2 Searching and Sorting Algorithms


## | Plotting
### 7.1 Plotting
